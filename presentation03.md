#Strategy Pattern

-추상클래스에 모아놓은 행위에 변경이 생길경우 어떻게 해야하는가?  
-기존 소스를 수정해야함  
-추상클래스가 변경에 닫혀있지않기때문에 OCP에 위배된다.  
-Atom과 TaekwonV 클래스의 move가 동일한 행위를 할경우 소스의 중복이 발생한다  

* Keypoint  
-캡슐화 단위에 따라 새로운 로봇을 추가하기는 매우 쉽다.

**해결책**
-변화되는 것을 캡슐화해야한다

* Strategy Pattern  
-전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴

* Keypoint  
-같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.

#Singleton Pattern
-하나의 클래스는 하나의 인스턴스만을 생성한다.

-간단한 방법 : 생성자를 외부에서 호출할 수 없게 만든다  
-방법 : 생성자를 private으로 선언한다  
-생성자를 호출할 수 없으므로 인스턴스를 제공해줄 메서드가 필요

**문제점**  
-Printer 인스턴스가 아직 생성되지 않았을때 스레드 1이 인스턴스가 생성되었는지 확인한다. 현재는 null인 상태다.  
-스레드 1이 인스턴스를 만들기 전 스레드 2가 null체크를 진행한다.  
-두 스레드가 모두 객체를 생성하면 결국 인스턴스는 2개가 생선된다.

* Keypoint  
-위 시나리오는 race condition을 발생시킨다. 경합 조건이란 메모리와 같은 동일한 자원을 2개 이상의 스레드가 이용하려고 경합하는 현상을 말한다.

**해결책**  
-정적 변수에 인스턴스를 만들어 바로 초기화하는 방법  
-인스턴스를 만드는 메서드에 동기화 하는 방법

**싱글턴 패턴과 정적 클래스**
* 정적 클래스를 사용할 수 없는 경우  
-인터페이스를 구현해야 하는 경우

#State Pattern
* 상태  
-객체의 라이프 사이클 동안 객체가 가질수 있는 어떤 조건이나 상황

**문제점**
-형광등에 새로운 상태를 추가한다면?

* Keypoint  
-복잡한 조건문에 상태변화가 숨어있는 경우 상태변화가 어떻게 이루어지는지 이해하기 어렵고 새로운 상태 추가에 맞춰 모든 메서드를 수정해야 한다.

**해결책**
-Strategy Pattern에서 전략 클래스에 작업을 위임하듯 상태 클래스에 작업을 위임한다

* Keypoint
-스테이트 패턴은 사태에 따라 동일한 작업이 다른 방식으로 실행될 때 해당 상태가 작업을 수행하도록 위임하는 디자인패턴이다.