#SOLID

**SRP(Single Responsibility Principle) - 단일책임원칙**  
하나의 클래스는 하나의 책임(역할)만을 진다.  

* Keypoint  
-책임 = 해야하는 것  
-책임 = 할 수 있는 것  
-책임 = 해야하는 것을 잘 할 수 있는 것  

* 변경  
-요구사항에 대한 변경은 언제나 존재한다.  
-변경사항이 생기지 않기를 바라는것보다 변경사항에 보다 유연하게 대처할 수 있는 방법이 찾는 것이 빠르다.  
-변하지않는 사실은 모든 것이 변한다는 것.  
-하나의 책임만을 가진다는것은 변경사항이 발생했을때 해당 클래스가 변경될 이유는 하나라는 것.  
-또한 다중 역할을 하는 클래스는 내부에서 서로 관련없는 클래스들끼리 강결합이 발생할 여지도 많다.  

* Keypoint  
-책임 = 변경이유  

* 책임 분리  
-다중 역할을 하는 클래스는 변경될 이유가 많다는 뜻이고 해당 클래스의 로직과는 크게 연관없는 로직에도 영향을 미칠 수가있다.  
-이는 유지보수의 난이도 증가와 사이드이펙트에 대한 부담감이 커진다는 것.  
-그다지 상관없는 부분까지도 영향도를 따져가며 회귀테스트를 해야한다.  
-이런 문제를 해결하기 위한것이 책임 분리이고, 다중 역할을 하고있는 클래스를 분리하는 것을 말한다.  

* 산탄총 수술  
-여러 역할을 하는 하나의 클래스를 분리하는것이 책임 분리라면 한 역할을 여러 클래스가 하고있는것을 재설계하는것이 산탄총 수술이다.  
-주로 비즈니스의 핵심로직인 종단 관심사보다는 부가기능(로깅, 트랜잭션 등)을 담당하는 횡단 관심사가 해당된다.  
-보통 이런 부가기능을 담당하는 클래스를 따로 설계해 호출하는 방식으로 사용. 허나 어쨋든 해당 클래스를 호출하는 부분이 핵심 로직내에 존재할 수 밖에 없다.  

* 관심지향 프로그래밍과 횡단 관심 문제  
-횡단 관심사를 수행하는 코드를 따로 객체로 모듈화하고 위빙작업을 통해 해결

* Keypoint  
-응집도 : 클래스나 메서드 내에 존재하는 코드들이 서로 얼마나 연관이 있는가의 척도. 클래스가 하나의 역할만 한다면 클래스내 모든 코드들이 서로에게 협력할것이므로 응집도가 높아진다.  
반면 다중 역할을 할 경우 서로 상관없는 코드들이 존재하게 되는것이므로 응집도가 낮아진다.  
-결합도 : 프로그램 구성 요소들 사이가 얼마나 의존적인지를 나타내는 척도. A클래스가 B클래스를 호출하고있을때 B클래스가 변경됐다는 이유로 A클래스에도 변경이 이루어진다면 두 클래스의 결합도가 높다고 표현한다.  
-응집도는 높이고 결합도는 낮춰라.  

* Keypoin_AOP 용어  
-조인포인트 : 애플리케이션 실행중의 특정한 지점. 횡단 관심사를 실행시킬 지점.  
-어드바이스 : 실행시킬 횡단 관심사의 코드.  
-포인트컷 : 횡단 관심사의 코드를 실행시킬 대상을 선정하는것.  
-애스펙트 : 어드바이스와 포인트컷의 조합물(스프링에서는 어드바이저라고 표현)  
-위빙 : 애플리케이션 코드에 실제로 횡단 관심사 소스를 투여하는 과정. 컴파일 AOP는 빌드 중에 발생하며, 실행 AOP는 런타임중 동적으로 발생한다.  

**OCP(Open Closed Principle) - 개방폐쇄원칙**  
클래스는 변경에는 닫혀있고 확장에는 열려있다.  

-결국에는 실제 핵심로직을 담당하는 서비스 객체를 구현클래스로 참조 하는것이 아니라 인터페이스를 이용하여 참조, 다형성을 사용하여 로직을 담당하는 객체가 추가되어도 클라이언트 클래스엔 변경부분없이 없어야한다는것.  
-클라이언트 클래스는 인터페이스만 알고있으면 되기때문에 변경에는 닫혀있게되고 서비스 클래스는 인터페이스를 이용해 구현되어있기때문에 언제든 추가 구현클래스를 확장할수있다.  

* Keypoint  
-클래스 = 변화의 단위  

* Keypoint  
-더미객체 : 테스트하고자하는 모듈이 다른 객체에 의존하고있는 경우 해당 테스트 성공만 할 수 있도록 빈 객체를 만드는 것  
-테스트 스텁 : 더미객체에 간단한 상태와 행위가 추가 된것.  
-테스트 스파이 : 테스트하고자 하는 클래스가 해당 객체를 호출했는지까지 확인할 수 있는 객체  
-가짜 객체 : 실제 의존 클래스의 기능을 대체해야할 경우 사용, 실제 의존클래스가 구현되지 않았거나 실행시키기에 비용이 너무 큰 경우 테스트환경에서 가짜 객체를 만들어 사용  
-목 객체 : 미리 정의한 기대 값과 실제 호출을 단언문으로 비교해 문제가 있으면 테스트를 실패하게 한다. 테스트 더블의 모든 형태를 일컫는 의미로 사용되기도 한다.  

**LSP(Liskov Substitution Principle) - 리스코프 치환 원칙**  
서브 타입은 언제나 기반 타입으로 대체될 수 있어야 한다.  

* Keypoint  
-부모클래스와 자식클래스 사이의 행위가 일관성이 있어야 한다  

-LSP 관점에서 상속을 봤을때 상속은 부모의 행위를 변경(오버라이딩)하기 위해서 사용되면 안된다. 행위의 추가를 위해서 사용되어야 함.  
-피터코드의 상속규칙 중 하나 : 서브 클래스가 슈퍼 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행한다.  

* Keypoint  
-LSP를 만족시키는 간단한 방법은 재정의하지 않는 것이다.  

**DIP(Dependency Inversion Principle) - 의존 역전 원칙**  
구현된것이 아닌 추상화된것에 의존하라.  

* Keypoint  
-변화하기 쉬운 것, 자주 변화하는 것이 아닌 변화하기 어려운것, 거의 변화가 없는것에 의존하라는 원칙.  

* Keypoint  
-인터페이스나 추상클래스와 의존 관계를 맺도록 설계해야 한다.  
-인터페이스 = 변화지 않는 것  
-구체클래스 = 변하기 쉬운 것  

-DIP를 만족하면 의존성 주입(Dependency Injection)이라는 기술로 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있다.  

**ISP(Interface Segregation Principle) - 인터페이스 분리 원칙**  
인터페이스로 책임을 분리하라.  

-복합기는 하나의 클래스지만 여러 기능(역할)을 갖고있다.  
-각각의 클라이언트 클래스에서 필요한 기능만을 이용한 인터페이스로 참조하여 클래스의 역할을 제한하는 원칙.  

* Keypoint  
-ISP는 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.  

-SRP와 ISP의 차이  
-비대한 클래스를 SRP에 따라 여러 클래스로 분할하고 각자의 인터페이스를 제공한다면 ISP도 만족할 수 있다.  

* Keypoint  
-SRP를 만족한다고 반드시 ISP를 만족한다고는 할 수 없다.